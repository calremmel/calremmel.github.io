<!DOCTYPE html>
<html lang="en">
<head>
          <title>Chris Remmel</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta charset="utf-8" />
        <!-- twitter card metadata -->
<meta name="twitter:site" content="@chrisremmel">
<meta name="twitter:title" content="Fraud Detection in Python: Part One">
<meta name="twitter:description" content="">
        <!-- OG Tags -->
<meta property="og:url" content="https://calremmel.github.io/fraud-detection-part-one.html"/>
<meta property="og:title" content="Chris Remmel | Fraud Detection in Python: Part One" />
<meta property="og:description" content="" />
        <!-- favicon -->
        <!-- moment.js for date formatting -->
        <script src="https://calremmel.github.io/theme/js/moment.js"></script>
        <!-- css -->
        <link rel="stylesheet" type="text/css" href="https://calremmel.github.io/theme/css/main.css" />
		<script>
			
                /*! grunt-grunticon Stylesheet Loader - v2.1.2 | https://github.com/filamentgroup/grunticon | (c) 2015 Scott Jehl, Filament Group, Inc. | MIT license. */
    
    (function(e){function t(t,n,r,o){"use strict";function a(){for(var e,n=0;u.length>n;n++)u[n].href&&u[n].href.indexOf(t)>-1&&(e=!0);e?i.media=r||"all":setTimeout(a)}var i=e.document.createElement("link"),l=n||e.document.getElementsByTagName("script")[0],u=e.document.styleSheets;return i.rel="stylesheet",i.href=t,i.media="only x",i.onload=o||null,l.parentNode.insertBefore(i,l),a(),i}var n=function(r,o){"use strict";if(r&&3===r.length){var a=e.navigator,i=e.Image,l=!(!document.createElementNS||!document.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect||!document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image","1.1")||e.opera&&-1===a.userAgent.indexOf("Chrome")||-1!==a.userAgent.indexOf("Series40")),u=new i;u.onerror=function(){n.method="png",n.href=r[2],t(r[2])},u.onload=function(){var e=1===u.width&&1===u.height,a=r[e&&l?0:e?1:2];n.method=e&&l?"svg":e?"datapng":"png",n.href=a,t(a,null,null,o)},u.src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==",document.documentElement.className+=" grunticon"}};n.loadCSS=t,e.grunticon=n})(this);(function(e,t){"use strict";var n=t.document,r="grunticon:",o=function(e){if(n.attachEvent?"complete"===n.readyState:"loading"!==n.readyState)e();else{var t=!1;n.addEventListener("readystatechange",function(){t||(t=!0,e())},!1)}},a=function(e){return t.document.querySelector('link[href$="'+e+'"]')},c=function(e){var t,n,o,a,c,i,u={};if(t=e.sheet,!t)return u;n=t.cssRules?t.cssRules:t.rules;for(var l=0;n.length>l;l++)o=n[l].cssText,a=r+n[l].selectorText,c=o.split(");")[0].match(/US\-ASCII\,([^"']+)/),c&&c[1]&&(i=decodeURIComponent(c[1]),u[a]=i);return u},i=function(e){var t,o,a;o="data-grunticon-embed";for(var c in e)if(a=c.slice(r.length),t=n.querySelectorAll(a+"["+o+"]"),t.length)for(var i=0;t.length>i;i++)t[i].innerHTML=e[c],t[i].style.backgroundImage="none",t[i].removeAttribute(o);return t},u=function(t){"svg"===e.method&&o(function(){i(c(a(e.href))),"function"==typeof t&&t()})};e.embedIcons=i,e.getCSS=a,e.getIcons=c,e.ready=o,e.svgLoadedCallback=u,e.embedSVG=u})(grunticon,this);
                
                grunticon(["https://calremmel.github.io/theme/css/icons.data.svg.css", "https://calremmel.github.io/theme/css/icons.data.png.css", "https://calremmel.github.io/theme/css/icons.fallback.css"]);
            </script>
        <noscript><link href="https://calremmel.github.io/theme/css/icons.fallback.css" rel="stylesheet"></noscript>
        <!-- menu toggle javascript -->
        <script type="text/javascript">
            document.addEventListener("DOMContentLoaded", initMenu);
            
            function initMenu(){
                var menu = document.getElementById("menu");
                var menulink = document.getElementById("menu-link");
                menulink.addEventListener("click", function toggleMenu(){
                        window.event.preventDefault();
                        menulink.classList.toggle('active');
                        menu.classList.toggle('active');              
                    });
            };
        </script>



</head>
<body>
    <div role="banner" id="masthead">
        <header>
            <h1><a href="/">Chris's Blog</a></h1>
            <a href="#menu" id="menu-link">more stuff</a>
            <nav id="menu">
                <ul>
                            <li><a href="https://calremmel.github.io/category/dataviz.html">dataviz</a></li>
                            <li class="active"><a href="https://calremmel.github.io/category/fraud-detection.html">fraud-detection</a></li>
                            <li><a href="https://calremmel.github.io/category/project.html">project</a></li>
                </ul>
            </nav>
        </header>
    </div>
        <div class="page" role="main">
  <div class="article" role="article">
    <article>
        <footer>
            <a name="top"></a>
            <p>
              <time datetime=" 2019-04-20 00:00:00-04:00">
                <script>document.write(moment('2019-04-20 00:00:00-04:00').format('LL'));</script>
              </time>
            </p>
        </footer>
        <header>
          <h2>
            Fraud Detection in Python: Part One
          </h2>
        </header>
      <div class="content">
         <h1>Visualization and Unbalanced Classes</h1>
<p><img alt="png" src="https://calremmel.github.io/images/pca_fraud_title.png"></p>
<p>Fraud detection is an important area of business where machine learning techniques have a particularly powerful use case. While fraud detection as a discipline predates the widespread popularity of machine learning, traditional techniques rely primarily on rules of thumb for flagging potentially fraudulent behavior. These rules can yield impressive results, but they cannot deal with interactions between different variables or improve over time the way a machine learning model can.</p>
<p>This is part one in a multi-part deep dive into the latest and greatest in fraud detection techniques using machine learning in the Python programming language. I'll be going through the very latest methods for predicting rare events like fraud, starting from the basics and proceeding through the cutting edge.</p>
<p>This series will be a set of living documents, and I will be updating them as much as I can as new ideas arise and as I learn more myself! Updates will be logged at the bottom of the page, so check there to see if there is anything new.</p>
<h1>Visualizing Fraud</h1>
<p>Part of what makes it so difficult to detect fraud is that <strong>fraud is rare.</strong> Within any given dataset of transactions, there will usually be far more legitimate cases than fraudulent ones. This makes it difficult to build a profile for what might distinguish fraud from non-fraud, and it makes it very difficult to avoid flagging legitimate transactions as fraud inadvertently when you try.</p>
<p>To get a sense of this, it is useful to have a way to visualize the frequency of fraud versus non-fraud. That's where we'll start.</p>
<p>Throughout this series, we'll be working with <strong>Synthetic Financial Datasets For Fraud Detection,</strong> generously provided by the Digital Forensics Research Group from NTNU in Gj√∏vik, Norway. An explanation of the dataset, the data dictionary, and the data itself are all available on Kaggle. <a href="https://www.kaggle.com/ntnu-testimon/paysim1">Feel free to download it if you would like to follow along</a>.</p>
<p>First, let's import the libraries we'll need, and take a first glance at the dataset.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="kn">as</span> <span class="nn">sns</span>

<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>

<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;../data/raw/PS_20174392719_1491204439457_log.csv&#39;</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>


<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>step</th>
      <th>type</th>
      <th>amount</th>
      <th>nameOrig</th>
      <th>oldbalanceOrg</th>
      <th>newbalanceOrig</th>
      <th>nameDest</th>
      <th>oldbalanceDest</th>
      <th>newbalanceDest</th>
      <th>isFraud</th>
      <th>isFlaggedFraud</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>PAYMENT</td>
      <td>9839.64</td>
      <td>C1231006815</td>
      <td>170136.0</td>
      <td>160296.36</td>
      <td>M1979787155</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>PAYMENT</td>
      <td>1864.28</td>
      <td>C1666544295</td>
      <td>21249.0</td>
      <td>19384.72</td>
      <td>M2044282225</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>TRANSFER</td>
      <td>181.00</td>
      <td>C1305486145</td>
      <td>181.0</td>
      <td>0.00</td>
      <td>C553264065</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1</td>
      <td>CASH_OUT</td>
      <td>181.00</td>
      <td>C840083671</td>
      <td>181.0</td>
      <td>0.00</td>
      <td>C38997010</td>
      <td>21182.0</td>
      <td>0.0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1</td>
      <td>PAYMENT</td>
      <td>11668.14</td>
      <td>C2048537720</td>
      <td>41554.0</td>
      <td>29885.86</td>
      <td>M1230701703</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>

<div class="highlight"><pre><span></span><span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">info</span><span class="p">())</span>
</pre></div>


<div class="highlight"><pre><span></span>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
RangeIndex: 6362620 entries, 0 to 6362619
Data columns (total 11 columns):
step              int64
type              object
amount            float64
nameOrig          object
oldbalanceOrg     float64
newbalanceOrig    float64
nameDest          object
oldbalanceDest    float64
newbalanceDest    float64
isFraud           int64
isFlaggedFraud    int64
dtypes: float64(5), int64(3), object(3)
memory usage: 534.0+ MB
None
</pre></div>


<p>This is a large dataset with well over six-million entries. Let's have a look at the data dictionary so we know what kind of information we have:</p>
<ul>
<li><strong>step</strong> - maps a unit of time in the real world. In this case 1 step is 1 hour of time. Total steps 744 (30 days simulation).</li>
<li><strong>type</strong> - CASH-IN, CASH-OUT, DEBIT, PAYMENT and TRANSFER.</li>
<li><strong>amount</strong> - amount of the transaction in local currency.</li>
<li><strong>nameOrig</strong> - customer who started the transaction</li>
<li><strong>oldbalanceOrg</strong> - initial balance before the transaction</li>
<li><strong>newbalanceOrig</strong> - new balance after the transaction</li>
<li><strong>nameDest</strong> - customer who is the recipient of the transaction</li>
<li><strong>oldbalanceDest</strong> - initial balance recipient before the transaction. Note that there is not information for customers that start with M (Merchants).</li>
<li><strong>newbalanceDest</strong> - new balance recipient after the transaction. Note that there is not information for customers that start with M (Merchants).</li>
<li><strong>isFraud</strong> - This is the transactions made by the fraudulent agents inside the simulation. In this specific dataset the fraudulent behavior of the agents aims to profit by taking control or customers accounts and try to empty the funds by transferring to another account and then cashing out of the system.</li>
<li><strong>isFlaggedFraud</strong> - The business model aims to control massive transfers from one account to another and flags illegal attempts. An illegal attempt in this dataset is an attempt to transfer more than 200.000 in a single transaction.</li>
</ul>
<p>It appears that part of our task will be to improve as much on <code>isFlaggedFraud</code> as possible. This is ideal, as it represents a typical rules-based heuristic for identifying fraud, and this is exactly the kind of benchmark we want to show we can outperform. We'll have a look at exactly how well they did at a later point in the series.</p>
<p>Next question: How many and what percentage of these entries are fraud?</p>
<div class="highlight"><pre><span></span><span class="n">counts</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;isFraud&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
<span class="n">counts</span>
</pre></div>


<div class="highlight"><pre><span></span>0    6354407
1       8213
Name: isFraud, dtype: int64
</pre></div>


<div class="highlight"><pre><span></span><span class="n">counts</span> <span class="o">/</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>


<div class="highlight"><pre><span></span>0    0.998709
1    0.001291
Name: isFraud, dtype: float64
</pre></div>


<p>Herein lies the central problem: only a little over <strong>.1%</strong> of these entries are fraudulent.</p>
<p>In order to make this more visually apparent, we'll use the following process:</p>
<ol>
<li>We'll take a large random sample from the dataset. I've learned from hard experience that plotting millions of points on your home laptop can take a good long while otherwise</li>
<li>We'll drop <code>nameOrig</code> and <code>nameDest</code> for now. These may be useful for modeling at a later point, but they will require some transformation, and for now we just want to get a sense of scale</li>
<li>We'll transform the <code>type</code> column into numeric dummy variables, so as to be able to include this information in our modeling</li>
<li>We'll reduce the dataset into two dimensions using Principal Component Analysis for plotting</li>
<li>We'll create a scatterplot of the reduced data, colored by fraudulent vs legitimate transactions</li>
</ol>
<div class="highlight"><pre><span></span><span class="c1"># Take random sample of dataset</span>
<span class="n">sample</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="c1"># Check to make sure that the sample is representative in terms of class ratio</span>
<span class="n">sample</span><span class="o">.</span><span class="n">isFraud</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
</pre></div>


<div class="highlight"><pre><span></span>0    9981
1      19
Name: isFraud, dtype: int64
</pre></div>


<div class="highlight"><pre><span></span><span class="c1"># Create a function to select and process features</span>
<span class="k">def</span> <span class="nf">get_features</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Selects and prepares features for plotting and modeling</span>

<span class="sd">    Args:</span>
<span class="sd">        df (DataFrame): Unprocessed fraud data</span>
<span class="sd">    Returns:</span>
<span class="sd">        df (DataFrame): Processed fraud data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">selected_cols</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="s1">&#39;amount&#39;</span><span class="p">,</span> <span class="s1">&#39;oldbalanceOrg&#39;</span><span class="p">,</span> <span class="s1">&#39;newbalanceOrig&#39;</span><span class="p">,</span>
        <span class="s1">&#39;oldbalanceDest&#39;</span><span class="p">,</span> <span class="s1">&#39;newbalanceDest&#39;</span><span class="p">,</span> <span class="s1">&#39;isFraud&#39;</span>
    <span class="p">]</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">selected_cols</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">dummies</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">dummies</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="c1"># Create a function to perform PCA on the features and return a DataFrame for plotting</span>
<span class="k">def</span> <span class="nf">reduce_data</span><span class="p">(</span><span class="n">pca_df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns features for plotting proportion of fraud</span>

<span class="sd">    Args:</span>
<span class="sd">        df (DataFrame): Synthetic fraud database</span>
<span class="sd">    Returns:</span>
<span class="sd">        plot_df (DataFrame): DataFrame with two principal components and target variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pca_df</span> <span class="o">=</span> <span class="n">pca_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">pca_df</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;isFraud&quot;</span><span class="p">)</span>
    <span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
    <span class="n">pca_df</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">pca_df</span><span class="p">)</span>
    <span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">components</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">pca_df</span><span class="p">)</span>

    <span class="n">comp_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">])</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">plot_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">comp_df</span><span class="p">,</span> <span class="n">target</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">plot_df</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="n">plot_df</span><span class="o">.</span><span class="n">columns</span>
</pre></div>


<div class="highlight"><pre><span></span>Index([&#39;X&#39;, &#39;y&#39;, &#39;isFraud&#39;], dtype=&#39;object&#39;)
</pre></div>


<div class="highlight"><pre><span></span><span class="c1"># Create a function for plotting</span>
<span class="k">def</span> <span class="nf">fraud_plot</span><span class="p">(</span><span class="n">plot_df</span><span class="p">,</span> <span class="n">maj_alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">min_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Plots reduced data</span>

<span class="sd">    Args:</span>
<span class="sd">        plot_df (DataFrame): Reduced data</span>
<span class="sd">        maj_alpha (float): Transparency setting for majority class</span>
<span class="sd">        min_alpha (float): Transparency setting for minority class</span>
<span class="sd">        save (str): Filename for saving plot</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">scatterplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">maj_alpha</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">plot_df</span><span class="p">[</span><span class="n">plot_df</span><span class="o">.</span><span class="n">isFraud</span> <span class="o">==</span> <span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Legitimate&quot;</span><span class="p">)</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">scatterplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">min_alpha</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">plot_df</span><span class="p">[</span><span class="n">plot_df</span><span class="o">.</span><span class="n">isFraud</span> <span class="o">==</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Fraud&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Legitimate vs Fraudulent Purchases&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">save</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">save</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">pass</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="c1"># Produce the plot!</span>
<span class="n">processed_data</span> <span class="o">=</span> <span class="n">get_features</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
<span class="n">plot_df</span> <span class="o">=</span> <span class="n">reduce_data</span><span class="p">(</span><span class="n">processed_data</span><span class="p">)</span>
<span class="n">fraud_plot</span><span class="p">(</span><span class="n">plot_df</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span></span>/home/calre/anaconda3/lib/python3.7/site-packages/sklearn/preprocessing/data.py:645: DataConversionWarning: Data with input dtype uint8, float64 were all converted to float64 by StandardScaler.
  return self.partial_fit(X, y)
/home/calre/anaconda3/lib/python3.7/site-packages/sklearn/base.py:464: DataConversionWarning: Data with input dtype uint8, float64 were all converted to float64 by StandardScaler.
  return self.fit(X, **fit_params).transform(X)
</pre></div>


<p><img alt="png" src="https://calremmel.github.io/images/fraud_pca_1.png"></p>
<p>There we go! The fraudulent entries are fairly well clustered, but they are very similar to many legitimate entries, and are completely dwarfed in number.</p>
<p>Having built these functions, we should now be able to visualize the changes we make to the distribution of our dataset as we move ahead into resampling.</p>
<h1>Resampling Techniques</h1>
<p>As we've seen, one of the central challenges in fraud detection is that cases of fraud are incredibly rare in comparison to legitimate transactions. This makes training a machine learning model challenging, because it means that if 1% of all transactions are fraudulent (this is still unrealistically high), the model would be able to achieve 99% accuracy simply by guessing that every single transaction is legitimate. Not what we want! This situation where there is much more of one class than another is called an <strong>imbalanced class problem.</strong></p>
<p>The way we deal with imbalanced classes is through <strong>resampling,</strong> which covers an array of techniques for making the ratio of classes more equitable. These techniques may be broadly separated into three categories:</p>
<ol>
<li><strong>Random Under-Sampling (RUS):</strong><ul>
<li>Take a random sample of the majority class and train the model on the sample combined with the entirety of the minority class</li>
</ul>
</li>
<li><strong>Random Over-Sampling (ROS):</strong><ul>
<li>Randomly sample from the minority class <em>with replacement</em> until the sizes of both classes match</li>
</ul>
</li>
<li><strong>Synthetic Minority Over-sampling Technique (SMOTE):</strong><ul>
<li>Creating new synthetic data for the minority class using K-Nearest Neighbors to create new minority cases that are representative but not exact duplicates</li>
</ul>
</li>
</ol>
<p>How to choose? <strong>RUS</strong> may be appropriate when there is a large enough population of the minority class that a representative sample of the majority class will make the class sizes equitable. RUS may be a good option in our case, as given our majority class size of 6354407 and minority class size of 8213, a sample size of 9589 for the majority class would give us a representative sample with a confidence of 95% and a margin of error of 1%.</p>
<p>For over-sampling techniques, given that our cases of fraud are similar enough to each other that KNN might produce good representative data, <strong>SMOTE</strong> could also produce good results. If our fraud cases were more spread out, creating synthetic data using KNN could produce wildly unrepresentative noise, throwing the model off.</p>
<p>If there is a situation where <strong>ROS</strong> would be preferable to both RUS and SMOTE, I'm not sure what that is! Training the model on duplicate data is a huge drawback, and could lead to serious overfitting on very specific data points.</p>
<p>In our case, as both <strong>RUS</strong> and <strong>SMOTE</strong> are solid options, we will try them both.</p>
<h2>Random Under-Sampling</h2>
<p>Both of our resampling strategies are implemented in the <code>imblearn</code> library. The documentation may be found <a href="https://imbalanced-learn.readthedocs.io/en/stable/index.html">by clicking here</a>. I'll explain the parameters we'll be using as we go along.</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">imblearn.under_sampling</span> <span class="kn">import</span> <span class="n">RandomUnderSampler</span>
</pre></div>


<p><code>RandomUnderSampler</code> does exactly what it says on the tin. The important parameter we need to tweak is called <code>sampling_strategy</code>. If you don't touch this setting, <code>RandomUnderSampler</code> will simply make the sizes of the larger classes match the size of the smallest class through random sampling without replacement. However, we want to make sure that we have a representative sample for the majority class, and using <a href="https://www.qualtrics.com/blog/calculating-sample-size/">this calculator</a> while asking for a 95% Confidence Level with a 1% Margin of Error suggests a slightly larger sample size of 9589.</p>
<p>Fortunately <code>sampling_strategy</code> can optionally take a dictionary, where the keys are class names, and the values are sample sizes. This allows us to set the exact sample size we want for the majority class.</p>
<div class="highlight"><pre><span></span><span class="c1"># Instantiate RandomUnderSampler</span>
<span class="n">RUS</span> <span class="o">=</span> <span class="n">RandomUnderSampler</span><span class="p">(</span><span class="n">sampling_strategy</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">9589</span><span class="p">},</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="c1"># Create a function for use with any resampling method</span>
<span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Resamples df using method with .fit_resample()</span>

<span class="sd">    Args:</span>
<span class="sd">        df (DataFrame): Fraud data</span>
<span class="sd">        method (object): Resampler with .fit_resample() method</span>
<span class="sd">    Retuns:</span>
<span class="sd">        resampled_df (DataFrame): Resampled DataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">processed_df</span> <span class="o">=</span> <span class="n">get_features</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">processed_df</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;isFraud&#39;</span><span class="p">)</span>

    <span class="n">processed_x</span><span class="p">,</span> <span class="n">processed_y</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">fit_resample</span><span class="p">(</span><span class="n">processed_df</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

    <span class="n">cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">processed_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;isFraud&quot;</span><span class="p">]</span>

    <span class="n">pdf_x</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">processed_x</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">processed_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
    <span class="n">pdf_y</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">processed_y</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;isFraud&#39;</span><span class="p">])</span>
    <span class="n">resampled_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">pdf_x</span><span class="p">,</span> <span class="n">pdf_y</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">resampled_df</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="c1"># Apply RandomUnderSampler to data</span>
<span class="n">rus_resampled</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">RUS</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">rus_resampled</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">rus_resampled</span><span class="o">.</span><span class="n">isFraud</span><span class="o">.</span><span class="n">value_counts</span><span class="p">())</span>
</pre></div>


<div class="highlight"><pre><span></span>(17802, 11)
0    9589
1    8213
Name: isFraud, dtype: int64
</pre></div>


<div class="highlight"><pre><span></span><span class="n">fraud_plot</span><span class="p">(</span><span class="n">reduce_data</span><span class="p">(</span><span class="n">rus_resampled</span><span class="p">),</span> <span class="n">min_alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>


<p><img alt="png" src="https://calremmel.github.io/images/fraud_pca_2.png"></p>
<p>The result of our work is a nicely balanced dataset, using all real data and a representative random sample of the majority class.</p>
<p>Let's wrap up by applying SMOTE, which should be a snap given that we've already prepared the major groundwork using the functions we've written to this point.</p>
<h2>SMOTE</h2>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">imblearn.over_sampling</span> <span class="kn">import</span> <span class="n">SMOTE</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="c1"># Instantiate SMOTE</span>
<span class="n">SM</span> <span class="o">=</span> <span class="n">SMOTE</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="c1"># Use our helpful resampling function</span>
<span class="n">sm_resampled</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">SM</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">sm_resampled</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">sm_resampled</span><span class="o">.</span><span class="n">isFraud</span><span class="o">.</span><span class="n">value_counts</span><span class="p">())</span>
</pre></div>


<div class="highlight"><pre><span></span>(12708814, 11)
1    6354407
0    6354407
Name: isFraud, dtype: int64
</pre></div>


<div class="highlight"><pre><span></span><span class="c1"># Take random sample for easier plotting</span>
<span class="n">sm_sample</span> <span class="o">=</span> <span class="n">sm_resampled</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="c1"># Produce the plot!</span>
<span class="n">fraud_plot</span><span class="p">(</span><span class="n">reduce_data</span><span class="p">(</span><span class="n">sm_sample</span><span class="p">),</span> <span class="n">min_alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>


<p><img alt="png" src="https://calremmel.github.io/images/fraud_pca_3.png"></p>
<p>Again, we have a well balanced dataset. This dataset is much larger than the one produced by RUS, but contains a lot of synthetic data points. Because our original fraudulent data was so closely clustered, this hopefully shouldn't compromise the quality of our predictions. Notice that our plot is visually quite similar to the one produced by RUS.</p>
<h1>Next Steps</h1>
<p>That's enough for our first foray into the fundamentals of fraud detection in Python! To wrap up, here are the major takeaways in condensed form:</p>
<ol>
<li>Fraud is damaging, but it is also <strong>very rare.</strong> This is the central challenge for modeling fraud</li>
<li>A dataset where one class of interest is wildly outnumbered by other classes is said to be <strong>imbalanced</strong></li>
<li>It is useful to have visual strategies to get a sense for the scope of class imbalance in a dataset. We've learned to use <strong>PCA and scatterplots</strong> in order to visualize these relationships</li>
<li>In order to prepare an imbalanced dataset for modeling, we need to apply <strong>resampling strategies</strong> to make the class balance more equitable. We learned about <strong>Random Under-Sampling (RUS)</strong> of the majority class, <strong>Random Over-Sampling (ROS)</strong> of the minority class, and <strong>Synthetic Minority Over-sampling Technique (SMOTE)</strong> for generating new representative minority class data</li>
</ol>
<p>In the next part of our deep dive, we'll cover common machine learning techniques for modeling fraud, and how to use them in pipelines with Scikit-Learn. Thanks for reading, and stay tuned!</p>
      </div>
      <div class="back-to-top">
          <a href="#top">back to top</a>
      </div>
    </article>
  </div>
<!-- end article -->
                <footer>
                    <div class="icons">
                        <a href="https://twitter.com/chrisremmel" target="_blank"><div class="icon-twitter icon"></div></a>
                        <a href="https://github.com/calremmel" target="_blank"><div class="icon-github icon"></div></a>
                    </div>
                    <p>¬© <script>document.write(moment().format('YYYY'));</script> Chris Remmel</p>
                </footer>
        </div>
</body>
</html>